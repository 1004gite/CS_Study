# Algorithm  

## 파일명 규칙  

문제난이도_(사이트약자)(문제번호).확장자  
ex) PP_bj1300.cpp, X_bj11210.py  

```
* O = 해결 && 정리할필요 없음  
* P = 해결했는데 정리할 필요 있음  
* PP = 해결했는데 난이도가 있었다. 나중에 꼭 보기  
* PPP = 해결했는데 고민을 굉장히 많이 했거나 시행착오가 많아 여러번 다시 봐야할 문제  
* X = 아직 해결 못함  
```
  
### 코틀린 컴파일  
kotlinc-jvm *.kt  
kotlin *kt

### 알고리즘  
- ### 번외
### Two Pointer
> start, end 두개의 pointer를 이용하여 문제를 푸는 기법
> > 모든 길이의 구간에서 특정 조건을 brute force하게 검사하는 데는 O(N^2)이 소요된다.  
> > start와 end pointer를 옮겨가며 start가 끝까지 갈떄까지 검사한다면 O(N)으로 해결할 수 있다.  
> > 이떄 조건이 번위내의 합 같은 연속적이고 대소비교가 가능한 값이어야 한다.

### 구간내의 합 구하기
> 여러 구간내의 합을 구하는데 사용할 수 있는 방법이다.  
> 여러 구간의 합을 일일이 구하면 비용이 많이 발생한다.  
> 0번index부터 마지막 index까지 누적합을 구해놓는다면 구간 사이의 차를 이용해 한번에 값을 구할 수 있다. 

### 다익스트라  
> 최단경로 탐색 알고리즘  
> 특정 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려준다.  
> 최단거리를 구할때 이전 최단거리를을 참고한다는 점에서 dp와 비슷하다. 
> > 추가적으로 어떤 최단 경로에 있는 경로들은 해당 node까지의 최단경로이다.  
> > 또, 시작점으로부터 가장 짧은 경로를 보장하며 진행하기 때문에 한번 업데이트 된 node는 최단경로임을 보장할 수 있다.  
> 1. 출발 노드를 설정한다.
> 2. 출발 노드를 기준으로 각 노드의 최소 비용을 저장한다.
> 3. 방문하지 않은 노드 중 가장 비용이 적은 노드를 선택한다.
> 4. 해당 노드를 거쳐 특정한 노드로 가는 경우를 고려하여 최소 비용을 갱신한다.
> 5. 3~4번을 반복한다.  
> 음의 간선이 존재하는 경우에는 사용할 수 없다.  
> - 가장 적은 비용이 드는 node를 고르는 방법
> > 1. Priority Queue를 이용한다.
> > 2. 방문 기록을 남기고 매번 최소비용 node를 찾는다.
> > > 1번의 경우 node의 수가 너무 많으면(업데이트가 잦으면) 새로운 정보를 계속 넣어줘야 하기 때문에 오히려 비효율적일 수 있다.  