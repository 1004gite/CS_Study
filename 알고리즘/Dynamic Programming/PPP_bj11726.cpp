/*
2xn크기의 직사각형을 1x2, 2x1 크기의 타일로 채우는 방법의 수를 구하자

풀이 1
1. 2*1 한칸에 대해서는 2*1 타일로만 채울 수 있다.
2. 2*2에 대해서는 2*1두개 또는 1*2 두개로 채울 수 있다.
3. 2*3에 대해서는 2*1 + 2*2 또는 2*2 + 2*1로 볼 수있다.
    이떄, 2*2는 2개의 방법이 있고 2*1은 1개의 방법이 있다.
    즉, 2x1상태에서 2가지 방법으로 만둘 수 있고 2x2 상태에서 1개지 방법으로 만들 수 있다.
    이것을 확장하여 n번째 상태를 만드려면 (n-2상태 + 1) + (n-1상태 + 0) 으로 볼 수 있다.
4. 신경쓸 점
    n-2상태에서 2가지 방법으로 더하는 것과 n-1상태에서 1가지 방법으로 더하는 것 중 중복된 상황이 나올 수도 있다고 생각한다.
    예를 들어 세로 블럭 3개를 놓는 상황은
        세로 1개짜리에 세로 2개를 추가하는 경우와
        세로 2개짜리에 세로 1개를 추가하는 경우를 따로 카운트하게 된다.
    정리하자면 n-1상태에는 n-2상태에서 세로블럭을 하나 추가한 경우를 포함한다.
    즉, n-2상태에서 세로블럭 2개를 추가하는 경우는 n-1상태에서 고려되므로 고려하지 않는다.
5.  (n-2상태 + 1) + (n-1상태 + 0) -> (n-2상태 + 0) + (n-1상태 + 0)
6. 정답은 %10007 연산을 한 값이 되는데 mod 연산의 특성상
    피연산자를 전부 계산 후 적용하나 각각의 피연산자에 적용하나 같은 값을 가지기 때문에 각각 적용한다.
*/

#include <iostream>
#include <vector>

using namespace std;

vector<int> dp(1001,0);

int main(void){

    dp[1] = 1;
    dp[2] = 2;
    for(int i = 3; i <= 1000; i++){
        dp[i] = (dp[i-1] + dp[i-2])%10007;
    }

    int n;
    cin >> n;
    printf("%d\n",dp[n]);
}