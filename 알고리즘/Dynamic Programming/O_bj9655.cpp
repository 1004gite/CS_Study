/*
돌 N개가 있고 번갈아가며 1or3개의 돌을 가져간다.
마지막 돌을 가져가는 사람이 이기게 된다.
SK, CY가 게임을 하고 SK가 먼저 돌을 가져간다.
두 사람 모두 최선의 경우로 게임을 했을 때 이기는 사람을 구하자.

풀이 1
1. N이 주어졌을 때 선공이 이기는지 후공이 이기는지만 알면 된다.
2. 남은 돌을 기준으로 생각할 때 어떤 사람이 이기려면 마지막 차례에 1~3개의 돌이 남아있어야 한다.
    그 전 상황은 4개개 남아있어야 한다.
    4개가 남아있게 하려면 5~7개의 돌이 그 전 상황에 남아있어야 한다.
    이기게 되는 사람을 기준으로 2턴에 4개씩 돌이 줄어들게 해야 한다.
    즉, 내 차례에 남은 돌이 4의 배수라면 이길 수 없고 아니라면 4의 배수개가 남게 만들어 이긴다.
3. N이 4의 배수라면 CY를 아니면 SK를 출력한다.
4. 또, N이 3보다 작거나 같다면 선공이 무조건 이긴다.

풀이 2
1. 1~3개가 아니라 1개 또는 3개만 가져갈 수 있기 때문에 풀이1로는 풀 수 없다.
2. 어떤 사람이 이기려면 남은 돌이 1개 또는 3개여야 한다.
    돌이 4개 남아있는 경우 그 차례의 사람은 이길 수 없다.
    돌이 4개 남아있게 하려면 그 전에 5개 또는 7개의 돌이 있어야 한다.
    위의 상황이 이루어지려면 8개의 돌만 남아있으면 된다.
    즉, 자신의 차례에 4의 배수만큼 돌이 남아있다면 이길 수 없다.
3. n이 4의 배수이거나 1or3을 빼서 4의 배수로 만들 수 없다면 SK가 이길 수 없다.
    즉, n이 4의 배수 or 4의배수 +2 이면 후공이 이긴다.

풀이 3
1. 풀이2는 정답이지만 dp를 이용해서 풀어보고 싶다.
2. 돌이 n개 남아있다면 sk의 차례이다.
3. 사람을 구분하지 않고 돌이 i개 남아있는 상황에서 이길 수 있는지를 기록해 나간다.
    돌이 i개 남아있다면 i-1ori-3개를 남길 수 있고 둘중 상대를 패배시킬 수 있는 상황이 있다면 이길 수 있다.
4. 돌이 1,3개 남아있다면 승리, 0,2개 남아있다면 패배한다는 조건에서 시작한다.
5. 돌이 n개 남았을 때는 선공인 sk의 차례이다.
*/

#include <iostream>
#include <vector>

using namespace std;

int main(void){

    int n;
    cin >> n;

    // 승리 == 1, 패배 == 0
    vector<int> dp(1001);
    dp[1] = 1;
    dp[3] = 1;
    dp[0] = 0;
    dp[2] = 0;

    for(int i = 4; i <= n; i++){
        /*
        이번 차례에는 돌이 i개 남아있다
        이번 차례의 사람은 다음 상대에서 i-3||i-1개의 돌은 남길 수 있다.
        둘중 다음 상대를 패배하게 할 수 있는 경우의 수가 있다면 이길 수 있다.
        */
        if(dp[i-1] == 0 || dp[i-3] == 0){
            dp[i] = 1;
        }
        else{
            dp[i] = 0;
        }
    }

    if(dp[n] == 1) printf("SK\n");
    else printf("CY\n");

}





// 풀이 2 -> 정답
// #include <iostream>

// using namespace std;

// int main(void){

//     int n;
//     cin >> n;

//     if(n%4 == 0 || (n%4) == 2) printf("CY\n");
//     else printf("SK\n");
// }