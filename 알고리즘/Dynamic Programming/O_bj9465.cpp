/*
스티커 2n개가 n개씩 2행으로 배치되어있다.
어떤 스티커를 떼면 주변 스티커는 망가진다.
각 스티커에 점수가 있을 때 가능한 최대 점수를 구하자

값의 최대누적은 10,000,000으로 int를 사용한다.

풀이 1
1. 점수가 높은 스티커를 살리는 것이 유리하지만 주변에 큰 점수가 많을 수 있다.
    greedy하게 접근할 수 없다.
2. 어떤 스티커들은 연속으로 고르지 않아야 이득일 수 있다.
3. dp를 이용하여 한 행만 있다고 생각했을 때로 축소해서 생각해보자
    마지막 사진에 대해 고려할 때 이전값을 제외한 모든 누적값들 중 가장 큰값에 본인을 더하는 것
        또는 바로 이전값이 최대이다.
    마지막을 선택하는 전자에서는 4칸전보다 먼 스티커는 고려할 필요가 없다.
    (그 이전 스티커는 3,2,1칸전 스티커에서 고려되기 때문)
    즉, 어떤 스티커를 선택할 떄는 해당 스티커를 선택했을 때의 값과 이전의 최대 누적값을 비교한다.
4. 3번의 논리에서 2행이 되면 해당 스티커를 선택할 때 고랴해야 할 주변 스티커 개수가 많아진다.

풀이 2 -> 고려할게 너무 많아짐..
1. 풀이 1에서 스티커를 고르거나 안골랐을 때 중 하나를 선택하지 않고 각각의 최댓값을 저장한다.
2. 어떤 스티커를 선택할 때의 최댓값은 그동안의 누적값들 중 좌측과 위/아래를 선택한 경우를 제외하고 고려한다.
    (좌측에서 우측으로 고려한다)
3. 2번의 계산을 효율적으로 하기 위해
    뽑는 경우에는 왼쪽, 위/아래 가 강제적으로 뽑지 않은 상태가 되므로 이 둘을 비교한다.
    뽑지 않는 경우에는 왼쪽, 위/아래 의 모든 상태를 비교한다.
    이때 각 스티커는 뽑지 않는 경우/뽑는 경우가 모두 고려되어 있기 때문에 더 이전의 스티커를 비교할 필요가 없다.
4. 위/아래 중 위를 먼저 고려한다고 했을 때 위의 입장에서는 아래가 아직 고려되어있지 않다.
    아래 대신 대각선을 고른 경우와 대각선을 고르지 않은 경우 + 아래를 고려한다.

풀이 3
1. 열을 하나의 세트로 본다.
    한 행을 선택하면 나머지는 선택할 수 없다.
2. 열을 옮겨가며 나올 수 있는 값들을 저장한다.
    경우의 수는 1행선택/2행선택/선택안함 3가지이다.
3. 1행 선택 - 이전 열의 2행선택/선택안함 고려
    2행 선택 - 이전 열의 1행선택/선택안함 고려
    3행 선택 - 이전 열을 모두 고려
*/

#include <iostream>
#include <vector>

using namespace std;

// 순서대로 1행/2행/선택안함
vector< vector<int> > dp(3, vector<int>(100000, 0));
vector< vector<int> > A(2, vector<int>(100000));

int main(void){
    cin.tie(0);
    cin.sync_with_stdio(0);

    int t;
    cin >> t;

    while(t--){
        int n;
        cin >> n;
        // 스티커 값 받아오기
        for(int i = 0; i < n; i++){
            cin >> A[0][i];
        }
        for(int i = 0; i < n; i++){
            cin >> A[1][i];
        }
        dp[0][0] = A[0][0];
        dp[1][0] = A[1][0];

        for(int i = 1; i < n; i++){
            dp[0][i] = dp[1][i-1] > dp[2][i-1] ? dp[1][i-1] : dp[2][i-1];
            dp[1][i] = dp[0][i-1] > dp[2][i-1] ? dp[0][i-1] : dp[2][i-1];
            dp[2][i] = dp[0][i] > dp[1][i] ? dp[0][i] : dp[1][i];

            dp[0][i] += A[0][i];
            dp[1][i] += A[1][i];
        }

        int max = -1;
        for(int i = 0; i < 2;i++){
            if( dp[i][n-1] > max ) max = dp[i][n-1];
        }
        printf("%d\n",max);
        
        dp = vector< vector<int> >(3, vector<int>(100000,0));
    }
}