/*
길이 n인 수열에서 소수들을 골라 소수들의 최소 공배수를 구한다.

풀이 1
1. 소수들을 모두 찾는다.
2. 소수들을 모두 곱하여 결과값에 넣는다.
3. 최소 공배수를 만들 떄 공약수 값은 전체 곱에서 1번만 곱해도 되는 값이기 때문에 결과값을 공약수^(소수의 개수 -1)로 나눈다.
(최소 공배수를 소수들의 곱으로 나타냈을 때 소수들의 조합으로 모든 수들을 만들 수 있으면 된다. -> 공약수를 1개씩 공약수가 아닌데 다른 수안에 있는 소수들을 1개씩 넣는다.)
4. 3번대신 어떤 수를 공약수로 나눈 후 모두 곱한 뒤 마지막으로 공약수를 곱한다.
(수/공약수 = 공약수 외의 소수들의 곱)

풀이 2
풀이 1을 쓰다가 소수들을 골라 최소공배수를 만든다는 조건을 확인했다.
1. 에라토스 테네스의 체를 이용하여 1,000,000 까지의 소수를 구한다 (여러개의 소수를 찾아야 하기떄문에 에라토스 테네스의 체를 사용한다.)
2. 공약수가 1만 존재하기 때문에 모든 소수를 곱한다.
-> 수열에 중복된 수가 없다는 조건은 없기 때문에 같은 수가 있는지 확인해준다.
-> 나머지 연산을 해서 나머지가 0이면 이미 같은 소수가 곱해졌다는 것을 의미한다.
*/

#include <iostream>
#include <vector>

using namespace std;

vector<bool> table(1000001, true);

int main(void){

    table[0] = false;
    table[1] = false;
    for(int i = 2; i <= 1000; i++){
        if(table[i]){
            for(int x = 2; x*i <= 1000000; x++){
                table[x*i] = false;
            }
        }
    }

    cin.tie(0);
    cin.sync_with_stdio(0);

    int n;
    cin >> n;

    long long result = 1;
    long long tmp;

    while(n--){
        cin >> tmp;
        if(table[tmp] && result%tmp != 0){
            result *= tmp;
        }
    }

    if(result == 1){
        // 소수가 하나도 안곱해 졌을 때 (1은 소수가 아님)
        printf("-1\n");
    }
    else{
        printf("%lld\n",result);
    }
}