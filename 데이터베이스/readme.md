## NoSql Database  
> 관계형 database를 제외한 모든 database  
> csv, 파일시스템 등등  
> - 장점  
> 1. 스키마에 규정이 약하기 때문에 데이터의 확장에 유리하다.  
> 2. 유연한 데이터 구조를 가질 수 있다.
> 3. 서버 부하등으로 인해 장비를 추가해 데이터를 분산하는 경우를 scale-out이라고 하는데 이 경우 noSql이 유리하다. (빅데이터 분야등에 많이 쓰임)  
> - 단점  
> 1. 데이터 중복이 발생할 수 있다.  
>   때문에 중복이 있는 데이터를 업데이트 할때는 모든 관련 데이터를 업데이트 해야 한다.  
>   또, 저장공간 낭비가 일어날 수 있다.
  
## SQL Database 
> 모든 데이터를 2차원 테이블에 저장하고 테이블간 관계를 지정하는 database   
> 쿼리문을 사용하는 database들 (mysql 등)  
> - 장점  
> 1. 테이블 데이터에 중복이 없어 일관성이 있다.  
> 2. 구조가 명확하다.  
> 3. 트랜잭션이 있고 그 특징으로 인해 데이터의 일관된 상태를 유지한다.  
>   즉, 일부만 업데이트 되는 등의 불상사가 일어나지 않는다.  
> - 단점
> 1. 설계가 어렵다.  
> 2. 스키마를 변경하는데 많은 비용이 든다.  

## 트랜잭션  
> 데이터베이스에 작업을 주는 묶음  
> ex) 게시판에 글을 쓰면 insert, select문을 하나의 트랜잭션으로 설정할 수 있다.  
> - 원자성  
> 트랜잭션이 db에 모두 반영되거나 모두 반영되지 않아야 한다.  
> 만약 원자성이 보장되지 않을 경우 돈을 송금한 부분까지 적용되고 받는 부분은 적용되지 않는 등의 문제가 생길 수 있다.  
> - 일관성  
> 트랜잭션이 일어나기 전,후 모두 도메인의 유효범위, 제약조건 등을 위반하지 않는 상태여야 한다.  
> 만약 1000원이 있을 때 트랜잭션이 시작되었는데 도중에 1000원을 사용해 0원이 되었다고 하자. 그렇다면 처음 일어난 트랜잭션은 돈을 사용할 수 없어야 한다.  
> 단, 트랜잭션 도중에는 위배될 수 있다. 트랜잭션의 결과만 위배하지 않으면 된다.
> - 독립성  
> 둘 이상의 트랜잭션이 동시에 실행되고 있을 때, 다른 트랜잭션의 연산 결과에 관여할 수 없다.  즉, 같은 자원을 건드리는 각 트랜잭션이 순차적으로 실행되게 해야 한다.  
> - 영구성  
> 트랜잭션이 완료되었다면 그 결과는 영구적으로 저장되어야 한다.  
> 만약 완료 전에 문제가 생긴다면 원자성에 의해 트랜잭션 이전의 상태로 되돌아간다.  
> - Commit  
> 현재 상태를 반영한다.  
> - Rollback  
> 이전 commit 상태로 되돌린다.  
>
> 참고: mysql에서는 commit시 undo 영역에 반대되는 sql을 저장시켜놓는다.  처음 commit시 진향중인 트랜잭션이 있다면 취소하고 없다면 undo의 가장 최신 쿼리를 실행시켜 commit을 되돌린다.  
  
## 정규화  
> 데이터긴 중복을 제거하여 데이터 무결성을 보장하기 위함  
> 데이터 무결성: 데이터에 변경이 있을 때 중복된 데이터가 있다면 같은 내용에 대해 값이 달라질 수 있다. 같은 내용에 대해 같은 값을 보장하는 것을 데이터 무결성이라고 한다.  
> - 제 1 정규화  
> 하나의 col이 하나의 값을 갖게 한다.  
> 만약 취미 col에 {영화,게임}이라는 값이 있으면 2개의 행으로 나누어 저장한다.  
>
> - 제 2 정규화  
> 제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 하는 것이다.  
> 즉, 기본키의 부분집합이(일부가) 결정자가 되면 안된다.  
> <br/>
> ex) {학생, 과목, 학점}으로 이루어진 table이 있고 {학생, 과목}인 복합키를 사용한다고 하자.  
> 이 상태에서 "강의실" col을 추가한다면 기본키중 일부인 "과목"에 의해 "강의실"이 정해지므로 "강의실"은 결정자가 된다.  
> 제 2 정규화에서는 {과목, 강의실} 테이블을 따로 만들어 연결하게 분리해야 한다.  
> - 제 3 정규화  
> 제 2 정규화까지 마친 테이블에 이행적 종속을 제거하는 과정이다.  
> 이행적 종속이란 A->B, B->C가 만족할 때 A,B,C가 한 테이블에 있는 상태이다.  
> 테이블을 {A,B} {B,C}로 나누어서 이행적 종속을 제거한다.  
> 만약 이행적 종속이 있는 상태에서 B에 대한 C가 변하면 모든 A->C에 대해 변경을 적용해야 한다. 하지만 테이블이 분리되어 있다면 {B,C} 테이블에 수정이 한번만 있으면 B를 참조하는 A는 수정을 할 필요가 없다.  
> - BCNF 정규화  
> 제 3 정규화를 만족하는 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분리하는 과정이다.  
> 3 정규화와 비슷하지만 결정자는 항상 후보키가 되야 한다는 점이 다르다.(3 정규화의 강화버전)  
> // 3 정규화에서는 기본키에 포함되지 않는 결정자는 그냥 유지한다. 하지만 BCNF에서는 결정자는 무조건 후보키로 만든다.  
> <br/>
> - 정리  
> 1. col 안에 여러개의 값이 있다면 1 정규화 과정에서 여러개의 row로 나눈다.  
> 2. 기본키의 일부가 결정자라면 2 정규화에서 테이블을 나눠서 한 테이블 내에서 기본키의 일부가 값을 결정하는 일이 없게 한다.  
> 3. 이행적 종속을 제거하기 위해 테이블을 분리한다.  
> // 즉, 기본키를 제외한 모든 결정자를 제거한다.  
> 4. 모든 결정자가 후보키가 되게 한다.  
> // 즉, 기본키를 제외한 모든 결정자를 제거하며 후보키가 되게 한다.  