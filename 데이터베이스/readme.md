## NoSql Database  
> 관계형 database를 제외한 모든 database  
> csv, 파일시스템 등등  
> - 장점  
> 1. 스키마에 규정이 약하기 때문에 데이터의 확장에 유리하다.  
> 2. 유연한 데이터 구조를 가질 수 있다.
> 3. 서버 부하등으로 인해 장비를 추가해 데이터를 분산하는 경우를 scale-out이라고 하는데 이 경우 noSql이 유리하다. (빅데이터 분야등에 많이 쓰임)  
> - 단점  
> 1. 데이터 중복이 발생할 수 있다.  
>   때문에 중복이 있는 데이터를 업데이트 할때는 모든 관련 데이터를 업데이트 해야 한다.  
>   또, 저장공간 낭비가 일어날 수 있다.
  
## SQL Database 
> 모든 데이터를 2차원 테이블에 저장하고 테이블간 관계를 지정하는 database   
> 쿼리문을 사용하는 database들 (mysql 등)  
> - 장점  
> 1. 테이블 데이터에 중복이 없어 일관성이 있다.  
> 2. 구조가 명확하다.  
> 3. 트랜잭션이 있고 그 특징으로 인해 데이터의 일관된 상태를 유지한다.  
>   즉, 일부만 업데이트 되는 등의 불상사가 일어나지 않는다.  
> - 단점
> 1. 설계가 어렵다.  
> 2. 스키마를 변경하는데 많은 비용이 든다.  

## 트랜잭션  
> 데이터베이스에 작업을 주는 묶음  
> ex) 게시판에 글을 쓰면 insert, select문을 하나의 트랜잭션으로 설정할 수 있다.  
> - 원자성  
> 트랜잭션이 db에 모두 반영되거나 모두 반영되지 않아야 한다.  
> 만약 원자성이 보장되지 않을 경우 돈을 송금한 부분까지 적용되고 받는 부분은 적용되지 않는 등의 문제가 생길 수 있다.  
> - 일관성  
> 트랜잭션이 일어나기 전,후 모두 도메인의 유효범위, 제약조건 등을 위반하지 않는 상태여야 한다.  
> 만약 1000원이 있을 때 트랜잭션이 시작되었는데 도중에 1000원을 사용해 0원이 되었다고 하자. 그렇다면 처음 일어난 트랜잭션은 돈을 사용할 수 없어야 한다.  
> 단, 트랜잭션 도중에는 위배될 수 있다. 트랜잭션의 결과만 위배하지 않으면 된다.
> - 독립성  
> 둘 이상의 트랜잭션이 동시에 실행되고 있을 때, 다른 트랜잭션의 연산 결과에 관여할 수 없다.  즉, 같은 자원을 건드리는 각 트랜잭션이 순차적으로 실행되게 해야 한다.  
> - 영구성  
> 트랜잭션이 완료되었다면 그 결과는 영구적으로 저장되어야 한다.  
> 만약 완료 전에 문제가 생긴다면 원자성에 의해 트랜잭션 이전의 상태로 되돌아간다.  
> - Commit  
> 현재 상태를 반영한다.  
> - Rollback  
> 이전 commit 상태로 되돌린다.  