# 자료구조 정리
<br>  

### Set  
> 중복이 불가능하고 순서가 없다.  

### Map  
> key_value 쌍으로 이루어져 있고 key는 중복이 불가능하다.  

### List  
> 순서가 있는 collection 이다.  

### 최대 힙
> 기본적으로 complete binary tree 이다  
> 모든 부모가 자식보다 큰 값을 갖는 구조

### Queue
> 먼저 들어온 객체가 먼저 나가는 구조 (FIFO)   
> 객체의 추가는 뒷부분에서만 일어나고 객체의 삭제는 앞에선만 일어난다.

### Stack
> 나중에 들어온 객체가 먼저 나가는 구조 (FILO)
> 객체의 추가와 삭제가 모두 top에서 일어난다.

### Priority Queue
> 중요도가 가장 높은 원소를 가장 위로 보내는 구조이다.  
> 넣는 순서에 상관없이 중요도가 높은 원소가 가장 높이 있게 된다.  
> 내부적으로는 heap 구조를 사용해 정렬에 O(logN) 의 복잡도를 가진다.

### 이진 검색 tree
> 이진 tree 구조로 오른 쪽 node는 항상 부모보다 크고 왼쪽 node는 항상 부모보다 작다.  
> 모든 subtree도 같은 성질을 만족한다.

### tree
> 사이클이 없는 무방향 그래프
> 어떤 두 node 사이에 항상 1개의 경로가 존재한다.
>> 두 leaf 간의 거리가 가장 먼 경로의 길이를 tree의 지름이라고 한다.  
>>  
>> tree를 전위 순회하면 (node, left, right) 왼쪽에 있는 node부터 읽게 되고  
>> 중위 순회하면 (left, node, right) 위에서부터 깊이가 같다면 왼쪽부터 읽게 된다.  
>> 후위 순회하면 깊은것부터 깊이가 같다면 왼쪽부터 읽게 된다.  

### Two Pointer
> start, end 두개의 pointer를 이용하여 문제를 푸는 기법  
> > 모든 길이의 구간에서 특정 조건을 brute force하게 검사하는 데는 O(N^2)이 소요된다.  
> > start와 end pointer를 옮겨가며 start가 끝까지 갈떄까지 검사한다면 O(N)으로 해결할 수 있다.  
> > 이떄 조건이 번위내의 합 같은 연속적이고 대소비교가 가능한 값이어야 한다.  

### 구간내의 합 구하기  
> 여러 구간내의 합을 구하는데 사용할 수 있는 방법이다.  
> 여러 구간의 합을 일일이 구하면 비용이 많이 발생한다.  
> 0번index부터 마지막 index까지 누적합을 구해놓는다면 구간 사이의 차를 이용해 한번에 값을 구할 수 있다.  